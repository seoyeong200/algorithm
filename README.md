# 목차
- [Greedy algorithm](#_Greedy_algorithm)
- [Dijkstra algorithm](#_Dijkstra_Algorithm)

# Greedy algorithm

- 지금 가장 최적인 답을 근시안적으로 택하는 알고리즘, 현재 상황에서 지금 당장 좋은 것만 고른다.
- 관찰을 통해 탐색 범위를 줄이는 알고리즘
- 정당성 분석이 중요 : 단순히 지금 가장 좋은 방법을 반복해서 선택해도 최적의 해를 구할 수 있는지 검토하기.


## 노드 값의 합을 최대로 하기

→ 그리디 알고리즘으로 문제를 해결하려고 할 경우

<img src="./img/그리디 노드.jpg" width=600 />

: 일반적인 상황에서 그리디 알고리즘은 최적의 해를 보장할 수 없을 때가 많다.

: 하지만 코딩 테스트에서 대부분의 그리디 문제는 탐욕법으로 얻은 해가 최적의 해가 되는 상황에서, 이를 추론할 수 있어야 풀리도록 출제된다.


## 예시 - 거스름돈 문제
500원, 100원, 50원, 10원 동전으로 N원을 거슬러줘야 할 때, 주는 동전의 최소 개수를 구하기. N은 항상 10의 배수다.




### 문제 해결 아이디어

- 가장 큰 단위의 동전부터 거슬러주면 된다.
N원을 거슬러줘야 할 때, 500원으로 거슬러 줄 수 있을 때까지 거슬러주고, 100원-50원-10원 순으로 각각 거슬러 줄 수 있을 때까지 거슬러준다.




### 정당성 분석

: 가장 큰 화폐 단위부터 돈을 거슬러주는 게 최적의 해를 보장하는 이유

- 동전들은 큰 단위가 항상 작은 단위의 배수이므로
- 작은 단위의 동전들을 종합해 다른 해가 나오는 경우가 없기 때문이다.
- 예를 들어, 화폐 단위가 500원, 400원, 100원이고 800원을 거슬러주는 상황이라면 그리디 알고리즘으로 문제를 해결할 수 없다.
```
N = 1260
count = 0
array = [500, 100, 50, 10]

for coin in array:
	count += N // coin
	N %= coin
```




### 시간 복잡도 O(K)

- K는 동전의 종류 개수
- for 문이 동전의 종류 수만큼 돈다.
- 거슬러줘야 하는 금액과 무관하게 동전의 총 종류에만 영향을 받는다.


* * *
* * *


# Dijkstra Algorithm
다이나믹 프로그래밍을 활용한 대표적인 최단 경로 탐색 알고리즘이다. 
- 최단 거리는 여러 개의 최단 거리로 이루어져 있기 때문에, 작은 문제가 큰 문제의 부분 집합에 속해있다고 볼 수 있다.
- 다익스트라는 하나의 최단 거리를 구할 때 이전까지 구해왔던 최단 거리 정보를 그대로 사용한다는 특징이 있다.

특정 정점에서 다른 모든 정점으로 가는 최단 경로를 알려준다. 다만 이 때 음의 간선을 포함할 수 없다. (이 특징 때문에 현실 세계에서 사용하기 매우 적합한 알고리즘 중 하나다.)




## - 작동 과정
1. 출발 노드 설정
2. 노드를 기준으로 각 노드의 최소 비용 저장
3. 방문하지 않은 노드 중 가장 비용이 적은 노드 선택
4. 해당 노드를 거쳐 다른 특정 노드로 가는 경우도 고려하여 최소 비용 갱신
5. 3 - 4 반복

<img src="./img/다익스트라 설명.jpeg" width=800 />




## Heap 자료구조
힙(Heap)은 특정한 규칙을 갖는 트리로, 최댓값과 최솟값을 찾는 연산을 빠르게 하기 위해 고안된 완전이진트리를 기반으로 한다.

A가 B의 부모노드일 때, A의 키 값과 B의 키 값 사이에는 대소 관계가 성립한다.
- 최소 힙 : 부모 노드 키 값 < 자식 노드 키 값
- 최대 힙 : 부모 노드 키 값 > 자식 노드 키 값

<img src="./img/힙.jpg" width=500 />


### 파이썬 heapq 모듈
: 리스트를 최소 힙처럼 다룰 수 있도록 하는 파이썬 내장 모듈

: 모든 부모 노드는 해당 자식 노드보다 값이 작은 이진트리 구조다.

- 사용 방법
```
import heapq 
#  빈 리스트 생성 후 원소 추가
heap = []
headq.heappush(heap, 10)


# 리스트를 힙 자료형으로 변환
heap = [10, 20, 30]
heapq.heapify(heap)

# 힙에서 원소 삭제
# heappop : 가장 작은 원소를 힙에서 제거함과 동시에 해당 원소 리턴
result = heapq.heappop(heap)

# 원소를 삭제하지 않고 가져오고 싶을 경우
# [0]
result = heap[0]
```












